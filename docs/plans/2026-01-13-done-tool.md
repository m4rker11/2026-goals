# `done` Tool Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement the unified `done` MCP tool that cascades updates to todos, logs, and daily tracking with a single call.

**Architecture:** Add a new `done` tool handler to tools.py with parsing helpers (parse_what, find_matching_task) as pure functions. The tool will search current week's todos for matching tasks, mark them done, optionally log durations, and sync to daily.yml. Existing tools remain functional (non-breaking change).

**Tech Stack:** Python 3.12, MCP SDK, ruamel.yaml for YAML preservation

---

## Task 1: Add `parse_what` Helper Function

**Files:**
- Create: `mcp-server/src/goals_mcp/done_helpers.py`

**Step 1: Create the helper module with parse_what function**

```python
"""Helper functions for the done tool."""

import re
from typing import NamedTuple


class ParsedWhat(NamedTuple):
    """Result of parsing the 'what' parameter."""
    duration: int | None  # Duration in minutes
    hint: str  # Task hint (remaining text after duration extraction)


def parse_what(what: str | None) -> ParsedWhat:
    """
    Extract duration and hint from 'what' parameter.

    Examples:
        "35 min run" -> ParsedWhat(duration=35, hint="run")
        "morning" -> ParsedWhat(duration=None, hint="morning")
        "0.5h yoga" -> ParsedWhat(duration=30, hint="yoga")
        "run-session" -> ParsedWhat(duration=None, hint="run-session")
        None -> ParsedWhat(duration=None, hint="")
    """
    if not what:
        return ParsedWhat(duration=None, hint="")

    what = what.strip()

    # Pattern 1: Minutes - "35", "35m", "35 min", "35 mins", "35 minutes"
    min_match = re.match(r'^(\d+)\s*(?:m|min|mins|minutes?)?\s*(.*)$', what, re.I)
    if min_match:
        duration = int(min_match.group(1))
        hint = min_match.group(2).strip()
        return ParsedWhat(duration=duration, hint=hint)

    # Pattern 2: Hours - "0.5h", "1.5hr", "2 hours"
    hr_match = re.match(r'^(\d+\.?\d*)\s*(?:h|hr|hrs|hours?)\s*(.*)$', what, re.I)
    if hr_match:
        hours = float(hr_match.group(1))
        duration = round(hours * 60)
        hint = hr_match.group(2).strip()
        return ParsedWhat(duration=duration, hint=hint)

    # No duration found - entire string is the hint
    return ParsedWhat(duration=None, hint=what)
```

**Step 2: Verify file was created**

Run: `ls -la mcp-server/src/goals_mcp/done_helpers.py`
Expected: File exists

---

## Task 2: Add `find_matching_task` Helper Function

**Files:**
- Modify: `mcp-server/src/goals_mcp/done_helpers.py`

**Step 1: Add the TaskMatch type and find_matching_task function**

Add after the parse_what function:

```python
from datetime import datetime


class TaskMatch(NamedTuple):
    """Result of finding a matching task."""
    status: str  # "ok", "ambiguous", "no_match"
    task: dict | None = None  # The matched task
    unit: str | None = None  # The unit (week-2, etc.)
    candidates: list | None = None  # For ambiguous matches
    duration: int | None = None  # Parsed duration


def get_day_abbrev(date_str: str) -> str:
    """Get day abbreviation (mon, tue, wed, etc.) from date string."""
    date = datetime.strptime(date_str, "%Y-%m-%d")
    days = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]
    return days[date.weekday()]


def find_matching_task(
    tasks: list[dict],
    hint: str,
    date_day: str,
    duration: int | None = None
) -> TaskMatch:
    """
    Find the best matching task from a list of tasks.

    Args:
        tasks: List of task dicts from todo.yml
        hint: Task hint from parse_what
        date_day: Day abbreviation (mon, tue, etc.)
        duration: Parsed duration in minutes

    Returns:
        TaskMatch with status and matched task(s)

    Matching priority:
        1. Exact ID match (score=100)
        2. Exact name match (score=90)
        3. Day-prefix + hint (score=80)
        4. Substring on ID (score=60)
        5. Substring on name (score=50)
    """
    candidates = []

    for task in tasks:
        if task.get("done"):
            continue  # Skip already done tasks

        task_id = task.get("id", "")
        task_name = task.get("name", "")

        score = 0
        match_reason = None

        # Priority 1: Exact ID match
        if hint and task_id == hint:
            score = 100
            match_reason = "exact_id"

        # Priority 2: Exact name match
        elif hint and task_name.lower() == hint.lower():
            score = 90
            match_reason = "exact_name"

        # Priority 3: Day-prefix + hint
        elif task_id.startswith(f"{date_day}-"):
            if not hint or hint.lower() in task_id or hint.lower() in task_name.lower():
                score = 80
                match_reason = "day_prefix"

        # Priority 4: Substring on ID
        elif hint and hint.lower() in task_id.lower():
            score = 60
            match_reason = "substring_id"

        # Priority 5: Substring on name
        elif hint and hint.lower() in task_name.lower():
            score = 50
            match_reason = "substring_name"

        if score > 0:
            candidates.append({
                "task": task,
                "score": score,
                "reason": match_reason
            })

    # Sort by score descending
    candidates.sort(key=lambda x: x["score"], reverse=True)

    if not candidates:
        return TaskMatch(status="no_match", duration=duration)

    if len(candidates) == 1 or candidates[0]["score"] > candidates[1]["score"]:
        return TaskMatch(
            status="ok",
            task=candidates[0]["task"],
            duration=duration
        )

    # Multiple matches with same score - ambiguous
    return TaskMatch(
        status="ambiguous",
        candidates=[c["task"] for c in candidates[:3]],
        duration=duration
    )
```

**Step 2: Add missing import**

At the top of the file, ensure:

```python
from datetime import datetime
```

---

## Task 3: Add `done` Tool Definition

**Files:**
- Modify: `mcp-server/src/goals_mcp/tools.py:40-95` (add after check_in Tool definition)

**Step 1: Add the done Tool definition in get_tool_definitions()**

Find the list of Tool definitions (around line 40) and add after the check_in tool:

```python
        # ==================== DONE ====================
        Tool(
            name="done",
            description="""Mark a goal task as done with automatic cascading updates.

Parses 'what' for duration and task hint:
- "35 min run" -> marks run task done, logs 35 min
- "morning" -> matches tue-morning on Tuesday
- "run-session" -> exact task ID match

Automatically:
- Finds matching task in current week's todos
- Marks the todo done
- Logs duration (if provided) to goal logs
- Updates daily.yml (calendar=true, fitness+=minutes, hindi+=1)
""",
            inputSchema={
                "type": "object",
                "properties": {
                    "goal": {
                        "type": "string",
                        "description": "Goal ID: fitness, calendar, work-boundaries, hindi, etc."
                    },
                    "what": {
                        "type": "string",
                        "description": "Task hint and/or duration: 'morning', '35 min run', 'run-session'"
                    },
                    "date": {
                        "type": "string",
                        "format": "date",
                        "description": "ISO date, defaults to today"
                    },
                    "notes": {
                        "type": "string",
                        "description": "Additional context"
                    }
                },
                "required": ["goal"]
            }
        ),
```

---

## Task 4: Add `handle_done` Handler Function

**Files:**
- Modify: `mcp-server/src/goals_mcp/tools.py` (add after handle_check_in function, around line 970)

**Step 1: Add import for done_helpers at the top of tools.py**

After the existing imports (around line 15), add:

```python
from .done_helpers import parse_what, find_matching_task, get_day_abbrev, TaskMatch
```

**Step 2: Add the handle_done function**

Add after handle_check_in (around line 970):

```python
def handle_done(arguments: dict) -> list[TextContent]:
    """
    Handle done tool - unified completion action with cascading updates.

    Behavior:
    1. Parse 'what' for duration and task hint
    2. Determine current week from date
    3. Search todos/{goal}/week-{N}.yml for matching task
    4. If match found: mark todo done, add notes
    5. If duration present: create log entry
    6. Sync to daily.yml based on goal type
    """
    goal_input = arguments.get("goal", "")
    what = arguments.get("what", "")
    date = arguments.get("date", get_today())
    notes = arguments.get("notes")

    if not goal_input:
        return [TextContent(type="text", text="goal is required")]

    # Resolve goal ID
    config = get_goals_config()
    goals = config.get("goals", {})
    goal_id = resolve_goal_id(goals, goal_input)

    if not goal_id:
        available = ", ".join(goals.keys())
        return [TextContent(type="text", text=f"Unknown goal: '{goal_input}'. Available: {available}")]

    # Parse 'what' for duration and hint
    parsed = parse_what(what)
    duration = parsed.duration
    hint = parsed.hint

    # Get date's day abbreviation
    date_day = get_day_abbrev(date)

    # Get current week for this date
    schedule = get_schedule()
    week_info = get_current_week(schedule)
    week_num = week_info.get("number", 1)

    # Check if the date falls in a different week
    for week in schedule.get("weeks", []):
        if week["start"] <= date <= week["end"]:
            week_num = week["number"]
            break

    unit = f"week-{week_num}"

    # Load tasks for this goal/unit
    todo = get_unit_todo(goal_id, unit)
    tasks = todo.get("tasks", [])

    # Find matching task
    match = find_matching_task(tasks, hint, date_day, duration)

    result_lines = []
    daily_updated = {}

    # Handle based on match status
    if match.status == "ok" and match.task:
        # Mark the task done
        task_id = match.task.get("id")
        task_name = match.task.get("name", task_id)

        updated = update_todo_task(
            goal_id, unit, task_id,
            done=True, notes=notes, clear_schedule=True
        )

        if updated:
            result_lines.append(f"Marked {task_id} done in {unit}")
            if notes:
                result_lines.append(f"Notes: {notes}")

            # If task had a calendar event, mark it complete
            cleared_event_id = updated.get("_cleared_event_id")
            if cleared_event_id:
                cal_result = calendar_service.mark_goal_complete(cleared_event_id)
                if cal_result.get("success"):
                    result_lines.append("Calendar event marked complete")

    elif match.status == "ambiguous":
        # Multiple matches - ask for clarification
        candidates = match.candidates or []
        candidate_strs = [f"  - {c.get('id')}: {c.get('name')}" for c in candidates]
        return [TextContent(type="text", text=f"Multiple matches for '{hint}':\n" + "\n".join(candidate_strs) + "\n\nSpecify task ID explicitly.")]

    elif match.status == "no_match":
        if duration:
            result_lines.append(f"No matching todo found for '{hint}' in {unit}")
        else:
            return [TextContent(type="text", text=f"No matching task for '{hint}' in {goal_id}/{unit}. Provide duration to log ad-hoc activity.")]

    # Log duration if provided
    if duration:
        logs = get_goal_logs(goal_id)

        # Find or create day entry
        day_entry = None
        for d in logs:
            if d.get("date") == date:
                day_entry = d
                break

        if not day_entry:
            day_entry = {"date": date, "entries": []}
            logs.append(day_entry)

        if "entries" not in day_entry:
            day_entry["entries"] = []

        entry = {"value": duration}
        if notes:
            entry["notes"] = notes

        day_entry["entries"].append(entry)

        # Update total
        total = sum(e.get("value", 0) for e in day_entry["entries"] if isinstance(e.get("value"), (int, float)))
        day_entry["total"] = total

        save_goal_logs(goal_id, logs)
        result_lines.append(f"Logged {duration} min to {goal_id}")

    # Sync to daily.yml based on goal type
    if goal_id == "fitness" and duration:
        current_daily = get_daily_entry(date)
        current_fitness = current_daily.get("fitness", 0) if current_daily else 0
        new_fitness = current_fitness + duration
        update_daily_entry(date, fitness=new_fitness)
        daily_updated["fitness"] = new_fitness

    elif goal_id == "calendar":
        update_daily_entry(date, calendar=True)
        daily_updated["calendar"] = True

    elif goal_id == "hindi":
        current_daily = get_daily_entry(date)
        current_hindi = current_daily.get("hindi", 0) if current_daily else 0
        new_hindi = current_hindi + 1
        update_daily_entry(date, hindi=new_hindi)
        daily_updated["hindi"] = new_hindi

    if daily_updated:
        updates_str = ", ".join(f"{k}={v}" for k, v in daily_updated.items())
        result_lines.append(f"Daily updated: {updates_str}")

    if not result_lines:
        return [TextContent(type="text", text="No action taken")]

    return [TextContent(type="text", text="\n".join(result_lines))]
```

---

## Task 5: Register `handle_done` in Tool Router

**Files:**
- Modify: `mcp-server/src/goals_mcp/tools.py` (find the handle_tool_call or similar dispatcher function)

**Step 1: Find the tool router**

Search for where tool calls are dispatched. Look for patterns like:
- `if name == "check_in":`
- `match name:`
- A dict mapping tool names to handlers

**Step 2: Add the done handler**

Add the routing for the done tool. Example patterns:

If using if/elif:
```python
elif name == "done":
    return handle_done(arguments)
```

If using match/case:
```python
case "done":
    return handle_done(arguments)
```

If using a dict:
```python
"done": handle_done,
```

---

## Task 6: Verify Import Structure

**Files:**
- Modify: `mcp-server/src/goals_mcp/__init__.py` (if needed)

**Step 1: Check if __init__.py needs updating**

Read the current __init__.py to see what's exported. Usually MCP servers don't need to export helper modules.

**Step 2: Verify the module structure works**

Run: `cd mcp-server && python -c "from goals_mcp.done_helpers import parse_what; print(parse_what('35 min run'))"`
Expected: `ParsedWhat(duration=35, hint='run')`

---

## Task 7: Manual Integration Test

**Files:** None (testing only)

**Step 1: Start the MCP server locally**

Run: `cd mcp-server && source .venv/bin/activate && python -m goals_mcp`
Expected: Server starts without import errors

**Step 2: Test done tool with example inputs**

Test these scenarios manually:
1. `done(goal="calendar", what="morning")` - should match wed-morning on Wednesday
2. `done(goal="fitness", what="35 min run")` - should match run-session, log 35 min
3. `done(goal="fitness", what="20 min walk")` - no match, logs ad-hoc 20 min
4. `done(goal="hindi", what="anki")` - should match anki-1/anki-2/anki-3

---

## Task 8: Commit Phase 1

**Files:** All modified files

**Step 1: Stage all changes**

Run: `git add mcp-server/src/goals_mcp/done_helpers.py mcp-server/src/goals_mcp/tools.py`

**Step 2: Commit**

Run:
```bash
git commit -m "$(cat <<'EOF'
feat(mcp): add unified done tool for cascading updates

Implements Phase 1 of design.md - the done tool that:
- Parses 'what' for duration and task hint
- Auto-matches tasks using day prefix + fuzzy matching
- Marks todos done automatically
- Logs duration to goal logs
- Syncs to daily.yml (calendar/fitness/hindi)

Non-breaking change - existing tools remain functional.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Notes for Implementer

**Key patterns from existing code:**
- `get_goals_config()` returns config with `goals` dict
- `resolve_goal_id(goals, input)` handles aliases
- `get_schedule()` returns schedule with `weeks` list
- `get_current_week(schedule)` returns `{number, start, end}`
- `get_unit_todo(goal_id, unit)` returns `{unit, tasks: [...]}`
- `update_todo_task()` handles done marking and schedule clearing
- `update_daily_entry()` creates/updates daily.yml entry

**Testing considerations:**
- Test on actual Tuesday/Wednesday to verify day prefix matching
- Test with tasks that are already done (should skip them)
- Test with no matching tasks but with duration (ad-hoc logging)
- Test work-boundaries goal (no daily sync, just todo marking)

**Edge cases to watch:**
- Empty `what` parameter - should match any day-prefixed task
- Week boundary dates - ensure correct week lookup
- Tasks already done - current behavior skips them
